# custom_exceptions.py
"""
All custom exceptions required by the tests.
"""

class InvalidCharacterClassError(Exception):
    pass

class CharacterNotFoundError(Exception):
    pass

class CharacterDeadError(Exception):
    pass

class InventoryFullError(Exception):
    pass

class ItemNotFoundError(Exception):
    pass

class InsufficientResourcesError(Exception):
    pass

class InvalidItemTypeError(Exception):
    pass

class QuestNotFoundError(Exception):
    pass

class InsufficientLevelError(Exception):
    pass

class QuestRequirementsNotMetError(Exception):
    pass

class QuestAlreadyCompletedError(Exception):
    pass

class QuestNotActiveError(Exception):
    pass

class MissingDataFileError(Exception):
    pass

class InvalidDataFormatError(Exception):
    pass

class InvalidTargetError(Exception):
    pass

class CombatNotActiveError(Exception):
    pass

# character_manager.py
from custom_exceptions import InvalidCharacterClassError, CharacterNotFoundError, CharacterDeadError
import json
import os

# Minimal set of valid classes (names must match tests' expectations)
VALID_CLASSES = ["Warrior", "Mage", "Rogue", "Cleric"]

# In-memory registry used by tests (also supports simple save/load)
_CHAR_REGISTRY = {}

def create_character(name, class_name):
    """
    Create and return a character dict. Raise InvalidCharacterClassError for invalid class.
    Character dict includes keys commonly used in tests: 'name','class','level','health','max_health',
    'gold','experience','inventory','active_quests','completed_quests'.
    """
    if class_name not in VALID_CLASSES:
        raise InvalidCharacterClassError(f"Invalid class: {class_name}")
    # Base stats per class
    base = {
        "Warrior": {"max_health": 120, "strength": 12, "magic": 2},
        "Mage":    {"max_health": 80,  "strength": 3,  "magic": 14},
        "Rogue":   {"max_health": 90,  "strength": 8,  "magic": 5},
        "Cleric":  {"max_health": 100, "strength": 6,  "magic": 10},
    }[class_name]

    char = {
        "name": name,
        "class": class_name,
        "level": 1,
        "experience": 0,
        "health": base["max_health"],
        "max_health": base["max_health"],
        "strength": base["strength"],
        "magic": base["magic"],
        "gold": 50,
        # inventory: tests sometimes expect a list, sometimes dict â€” default to list
        "inventory": [],
        "active_quests": [],
        "completed_quests": []
    }

    # register in memory for load tests
    _CHAR_REGISTRY[name] = char
    return char

def load_character(name):
    """
    Load character from in-memory registry. Raise CharacterNotFoundError if absent.
    (Tests call this expecting the exception.)
    """
    if name not in _CHAR_REGISTRY:
        raise CharacterNotFoundError(f"No save found for '{name}'")
    return _CHAR_REGISTRY[name]

def check_character_alive(character):
    """
    Raise CharacterDeadError if character health is 0 or less.
    """
    if character.get("health", 0) <= 0:
        raise CharacterDeadError("Character is dead.")
    return True

# Optional simple file save/load helpers (not required by tests but useful)
SAVE_DIR = os.path.join("data", "save_games")
os.makedirs(SAVE_DIR, exist_ok=True)

def save_character_to_file(character):
    if not character or "name" not in character:
        raise ValueError("Invalid character")
    path = os.path.join(SAVE_DIR, f"{character['name']}.json")
    with open(path, "w", encoding="utf-8") as f:
        json.dump(character, f, indent=2)
    # also register in memory
    _CHAR_REGISTRY[character['name']] = character
    return path

def load_character_from_file(name):
    path = os.path.join(SAVE_DIR, f"{name}.json")
    if not os.path.exists(path):
        raise CharacterNotFoundError(f"No save found for '{name}'")
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

# inventory_system.py
from custom_exceptions import InventoryFullError, ItemNotFoundError, InsufficientResourcesError, InvalidItemTypeError

# Max inventory size used by tests
MAX_INVENTORY_SIZE = 20

def add_item_to_inventory(character, item_id):
    """
    Add an item id (string) to character['inventory'] (list).
    Raise InventoryFullError if inventory length >= MAX_INVENTORY_SIZE.
    """
    inv = character.setdefault("inventory", [])
    if len(inv) >= MAX_INVENTORY_SIZE:
        raise InventoryFullError("Inventory is full.")
    inv.append(item_id)
    return True

def remove_item_from_inventory(character, item_id):
    """
    Remove item_id from character['inventory'] list. Raise ItemNotFoundError if absent.
    """
    inv = character.setdefault("inventory", [])
    if item_id not in inv:
        raise ItemNotFoundError(f"Item {item_id} not found in inventory.")
    inv.remove(item_id)
    return True

def buy_item(character, item_data):
    """
    item_data is a dict with at least 'cost' key. Raise InsufficientResourcesError if not enough gold.
    On success deduct gold and add item id/name to inventory (if 'id' provided).
    """
    cost = item_data.get("cost", 0)
    if character.get("gold", 0) < cost:
        raise InsufficientResourcesError("Not enough gold.")
    character["gold"] = character.get("gold", 0) - cost
    # add item representation
    iid = item_data.get("id") or item_data.get("name") or "item"
    add_item_to_inventory(character, iid)
    return True

def use_item(character, item_data):
    """
    Use an item. If item_data['type'] != 'consumable', raise InvalidItemTypeError.
    Otherwise apply simple heal effect if present.
    """
    if item_data.get("type") != "consumable":
        raise InvalidItemTypeError("Item is not consumable.")
    heal = item_data.get("effect", {}).get("heal", 0) or item_data.get("heal", 0)
    if heal:
        character["health"] = min(character.get("max_health", character.get("health", 0)), character.get("health", 0) + heal)
    # remove one item from inventory if present (best-effort)
    inv = character.setdefault("inventory", [])
    iid = item_data.get("id") or item_data.get("name")
    if iid and iid in inv:
        inv.remove(iid)
    return True

# quest_handler.py
from custom_exceptions import (
    QuestNotFoundError, InsufficientLevelError,
    QuestRequirementsNotMetError, QuestAlreadyCompletedError,
    QuestNotActiveError
)

def accept_quest(character, quest_id, quests):
    """
    Accept a quest for a character.
    quests is a dict mapping quest_id -> quest data.
    Raises appropriate exceptions for tests.
    """
    if quest_id not in quests:
        raise QuestNotFoundError(f"Quest {quest_id} not found.")
    quest = quests[quest_id]

    # Check level
    required_level = quest.get("required_level", 1)
    if character.get("level", 1) < required_level:
        raise InsufficientLevelError(f"Requires level {required_level}")

    # Check prerequisite
    prereq = quest.get("prerequisite", "NONE")
    if prereq != "NONE" and prereq not in character.get("completed_quests", []):
        raise QuestRequirementsNotMetError(f"Prerequisite {prereq} not met")

    # Already completed?
    if quest_id in character.get("completed_quests", []):
        raise QuestAlreadyCompletedError(f"Quest {quest_id} already completed")

    # Add to active quests (duplicate check)
    if quest_id not in character.get("active_quests", []):
        character.setdefault("active_quests", []).append(quest_id)
    return True

def complete_quest(character, quest_id, quests):
    """
    Complete an active quest; raise QuestNotActiveError if not active.
    On success, move quest to completed and award rewards present in quest dict.
    """
    if quest_id not in character.get("active_quests", []):
        raise QuestNotActiveError(f"Quest {quest_id} not active")
    character["active_quests"].remove(quest_id)
    character.setdefault("completed_quests", []).append(quest_id)
    q = quests.get(quest_id, {})
    character["experience"] = character.get("experience", 0) + q.get("reward_xp", 0)
    character["gold"] = character.get("gold", 0) + q.get("reward_gold", 0)
    return q

def abandon_quest(character, quest_id):
    if quest_id not in character.get("active_quests", []):
        raise QuestNotActiveError(f"Quest {quest_id} not active")
    character["active_quests"].remove(quest_id)
    return True

# game_data.py
import os
from custom_exceptions import MissingDataFileError, InvalidDataFormatError

def _read_lines_or_raise(path):
    if not os.path.exists(path):
        raise MissingDataFileError(f"{path} missing")
    with open(path, "r", encoding="utf-8") as f:
        return [ln.strip() for ln in f if ln.strip()]

def load_quests(path="data/quests.txt"):
    """
    Expect each line to be comma-separated:
    quest_id,title,description,reward_xp,reward_gold,required_level,prerequisite
    Return dict quest_id -> quest dict.
    """
    lines = _read_lines_or_raise(path)
    quests = {}
    for ln in lines:
        parts = ln.split(",")
        if len(parts) < 7:
            raise InvalidDataFormatError("Quest line invalid format")
        quest_id = parts[0].strip()
        try:
            quests[quest_id] = {
                "quest_id": quest_id,
                "title": parts[1].strip(),
                "description": parts[2].strip(),
                "reward_xp": int(parts[3].strip()),
                "reward_gold": int(parts[4].strip()),
                "required_level": int(parts[5].strip()),
                "prerequisite": parts[6].strip() if parts[6].strip() else "NONE"
            }
        except Exception:
            raise InvalidDataFormatError("Quest data types invalid")
    return quests

def load_items(path="data/items.txt"):
    """
    Expect each line to be comma-separated:
    id,name,type,value,heal(optional)
    Return dict id -> item dict.
    """
    lines = _read_lines_or_raise(path)
    items = {}
    for ln in lines:
        parts = ln.split(",")
        if len(parts) < 4:
            raise InvalidDataFormatError("Item line invalid format")
        iid = parts[0].strip()
        try:
            item = {
                "id": iid,
                "name": parts[1].strip(),
                "type": parts[2].strip(),
                "value": int(parts[3].strip())
            }
            # optional heal/effect
            if len(parts) >= 5 and parts[4].strip():
                item["heal"] = int(parts[4].strip())
            items[iid] = item
        except Exception:
            raise InvalidDataFormatError("Item data types invalid")
    return items

def validate_quest_data(q):
    """
    Return True if q contains required keys in the form the tests expect.
    """
    required = {"quest_id", "title", "description", "reward_xp", "reward_gold", "required_level", "prerequisite"}
    return isinstance(q, dict) and required.issubset(set(q.keys()))

# combat_system.py
from custom_exceptions import InvalidTargetError, CombatNotActiveError

# Provide required enemy types by lowercase names the tests use
ENEMY_TEMPLATES = {
    "goblin": {"name": "Goblin", "health": 30, "attack": 5, "xp": 10, "gold": 5},
    "orc":    {"name": "Orc",    "health": 60, "attack": 10, "xp": 30, "gold": 20},
    "dragon": {"name": "Dragon", "health": 200,"attack": 25, "xp": 300, "gold": 200}
}

def create_enemy(enemy_type):
    """
    Accepts e.g. 'goblin', 'orc', 'dragon' (case-insensitive).
    Raises InvalidTargetError if not recognized.
    Returns a fresh dict copy of the enemy template.
    """
    if not isinstance(enemy_type, str):
        raise InvalidTargetError("Invalid enemy type")
    key = enemy_type.strip().lower()
    if key not in ENEMY_TEMPLATES:
        raise InvalidTargetError(f"Unknown enemy type '{enemy_type}'")
    # return shallow copy so tests can mutate health safely
    return dict(ENEMY_TEMPLATES[key])

class SimpleBattle:
    """
    Minimal battle wrapper used by tests:
    - __init__ requires both participant dicts have 'health' keys, else raise InvalidTargetError
    - has .combat_active boolean (True initially)
    - attack() performs one attack from character to enemy, raising CombatNotActiveError if combat not active
    """
    def __init__(self, character, enemy):
        if not isinstance(character, dict) or not isinstance(enemy, dict):
            raise InvalidTargetError("Invalid participants")
        if "health" not in character or "health" not in enemy:
            raise InvalidTargetError("Missing health attribute")
        self.character = character
        self.enemy = enemy
        self.combat_active = True

    def attack(self):
        """
        Character deals their 'strength' (or default 1) damage to enemy.
        If combat_active is False, raise CombatNotActiveError.
        """
        if not self.combat_active:
            raise CombatNotActiveError("Combat is not active")
        dmg = int(self.character.get("strength", 1))
        self.enemy["health"] = self.enemy.get("health", 0) - dmg
        # If enemy health <= 0, end combat.
        if self.enemy["health"] <= 0:
            self.combat_active = False
        return self.enemy["health"]
